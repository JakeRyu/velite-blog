---
title: RESTful API 네이밍에 대한 모든 것
description: 일관성, 가독성, 유지보수성 - 이 세가지는 좋은 API 설계의 삼위일체다. 일관된 네이밍은 개발자들이 무엇을 기대할지 알 수 있게 도와주고, 읽기 쉬운 이름은 인지적 부담을 줄여주며, 유지보수성이 좋은 이름은 업데이트를 쉽게 한다.
date: 2024-05-30
tags: ["api"]
published: true
language: ko
---

# 잘못된 이름

`/getAllProducts`, `/UsersList`, `/payments/{memberId}` 같은 API 엔드포인트를 만났을 때 어떤 기분이 드는가? 나는 일관적이지 않고 불규칙한 작명을 보면 답답함을 느낀다. 잘못된 네이밍 컨벤션은 가장 단순한 작업조차 잘못된 사례로 전락시킬 수 있다.

## 잘못된 예시와 문제점:

1. `/getAllProducts`
    - **Problem**: 이름에 동사(get)가 포함되어 있는데, 이는 HTTP 메서드(GET)로 표현되어야 한다. 동사를 포함한 이름은 특정 동작을 암시하기 때문에 자원이 아닌 액션을 나타낸다. RESTful API에서 모든 것은 자원(Resource)으로 간주하는데 상폼 정보는 `/products`라는 자원으로 접는하는 것이 좋다.
    - **Confusion**: `GET /getAllProducts`를 뜯어서 보자면 세가지 이유로 좋지 않다. 
      1. get이 중복 사용되었다. 
      1. `getAll`은 `products`와 의미가 중복된다.
      1. `/getTopSellingProducts`, `/getMostRecommendedProducts` 등 앞으로 추가 예상되는 엔드포인트 때문에 목록은 끝없이 늘어날 것이다.
      
      정리하자면 동사는 Http Verb로 대신하여, `GET /products`만으로 충분한 의미를 전달할 수 있다.

2. `/UsersList`

    - **Problem**: 복수 명사와 다른 명사(예, List)를 결합하는 것은 중복이고 깔끔하지 않다. 이름은 리소스 컬렉션을 나타내야 한다.
    - **Confusion**: `/UserDetails`를 예로 들면, 단일 사용자에 대한 상세정보들인지 다중 사용자들이 대상인지 헷갈린다. 이름의 일관성이 중요하다.

3. `/books/{authorId}`

    - **Problem**: 개발자들은 `/books/{authorId}`가 `authorId`를 사용하여 특정 책을 가져오는 데 사용된다고 생각할 수 있다.
    - **Confusion**: 이것은 실제로 특정 책이 아닌 저자 정보를 조회하기 때문에 혼란을 일으킬 수 있다. 이러한 오해는 결국 오류를 유발한다.


<Callout type="warning">
  # 좋은 이름 짓기의 중요함

  일관성, 가독성, 유지보수성 - 이 세가지는 좋은 API 설계의 삼위일체다. 일관된 네이밍은 개발자들이 무엇을 기대할지 알 수 있게 도와주고, 읽기 쉬운 이름은 인지적 부담을 줄여주며, 유지보수성이 좋은 이름은 업데이트를 쉽게 한다.
</Callout>

# 좋은 명명 규칙

## 일반 지침

1. **작업을 위한 HTTP 동사**: HTTP 메서드가 동작을 나타내게 하라. `/getBooks` 대신 `GET /books`를 사용하라.
1. **리소스에는 명사를 사용하라**: 리소스를 엔터티로 생각하라. 예를 들어, `/users`와 `/orders`는 직관적이고 명확하다.
1. **복수형 이름을 사용하라**: `/books`와 같은 복수형 이름은 컬렉션을 다루고 있음을 명확히 한다.
1. **단일 항목에는 URL 매개변수를 사용하라**: 단일 항목의 경우, 복수형 리소스 이름 바로 뒤에 URL 매개변수 `{resourceId}`를 사용하라. 예를 들어, `/users/{userId}`와 `/books/{bookId}`는 컬렉션 내 특정 항목을 참조하고 있음을 명확히 나타낸다.
1. **스타일**:
    - 계층적 관계를 나타내기 위해 슬래시를 사용하라.
    - 가독성을 높이기 위해 하이픈 `-`을 사용하라 (`/user-orders` vs `/user_orders`).
    - 소문자를 사용하라.
    - 슬래시로 끝내지 마라.
    - 밑줄 `_`은 링크 서식과 혼동될 수 있으므로 사용하지 마라.
    - `/managed-devices.xml`처럼 파일 확장자는 사용하지 마라.

## URI 리소스 구조

1. **계층적 관계**: `/users/{userId}/orders`와 같이 관계를 나타내라.
2. **필터링, 정렬, 페이지 매김**: 이러한 작업에는 쿼리 매개변수를 사용하라. 예를 들어:
    - 필터링: `/books?author=tolkien`
    - 정렬: `/books?sort=asc`
    - 페이지 매김: `/books?page=2`
3. **버전 관리**: 하위 호환성을 유지하고 버전이 지정된 URI로 변경 사항을 관리하라. 예를 들어, `/v1/books`를 사용하여 API의 버전 1을 나타내라.
4. **리소스 유형을 나타내기 위해 단수형 이름을 사용하라**: 특정 리소스 유형을 나타내야 하는 경우, 복수형 컬렉션 내에서 단수형 이름을 사용하라. 이렇게 하면 더 넓은 리소스 범주 내에서 하위 카테고리 또는 그 유형을 명확하고 일관되게 지정할 수 있다. 예를 들어,
    - `GET /user-management/users/admin`: 이 URI는 사용자 관리 컨텍스트 내에서 "admin" 유형의 사용자를 가져온다는 것을 명확히 나타낸다. admin을 지정함으로써 특정 사용자 카테고리를 나타낸다. 이 접근 방식은 모호성을 피하고  admin 역할을 가진 사용자 리소스의 하위 집합임을 명확히 한다.
5. **컨트롤러 리소스를 나타내기 위해 동사를 사용하라**: 컨트롤러 리소스를 실행 가능한 함수처럼 취급하고 동사를 사용하여 동작을 명확히 나타내라. 이를 통해 표준 리소스 작업과 특정 명령 또는 작업을 구분할 수 있다. 예를 들어,
    - `POST /cart-management/users/{id}/cart/checkout`: 이 엔드포인트는 사용자의 장바구니를 체크아웃하는 동작을 나타낸다. checkout 동사는 이것이 단순한 리소스 조작이 아니라 명령 또는 작업임을 명확히 나타낸다.
    - `POST /song-management/users/{id}/playlist/play`: 이 URI는 사용자의 재생 목록을 재생하는 동작을 지정한다. play 동사는 이것이 재생 목록 리소스에서 수행되는 작업임을 명확히 나타낸다.
    
    이렇게 함수를 실행하는 듯이 사용할 경우 `POST`를 사용한다.

이러한 지침을 준수함으로써 직관적이고 사용하기 쉬운 API를 만들 수 있으며, 혼란을 줄이고 개발자의 경험을 향상시킬 수 있다.


# 일반적인 함정과 이를 피하는 방법
## 중첩된 리소스 남용

`/users/{userId}/orders/{orderId}/items/{itemId}`와 같은 깊은 중첩을 피하라. 단순하고 평평한 구조를 유지하라.

1. **평평한 리소스 구조**:<br />
깊게 중첩된 경로 대신 명확한 식별자가 있는 평평한 경로를 사용하라. 예를 들어, `/users/{userId}/orders/{orderId}/items/{itemId}` 대신 `/items/{itemId}`를 사용하고, 필요 시 관련 리소스 식별자를 쿼리 매개변수나 요청 본문(request body)에 포함하라.
    ```http
    GET /items/{itemId}?userId={userId}&orderId={orderId}
    ```
    위에서 아이템 식별자가 있어 해당 아이템을 직접 가져올 수 있더라도, `userId`와 `orderId`를 전달하는 것이 유익할 수 있다. 이러한 매개변수를 포함하면 엔티티간의 관계를 파악하기 위한 추가 데이터베이스 호출을 줄일 수 있다.

2. **쿼리 매개변수 사용:**<br />
쿼리 매개변수를 사용하여 리소스를 필터링한다. 다음 예는 필터링 결과로 만들어진 아이템 리스트를 반환한다. `/items/orders`, `/items/users` 처럼 중첩 리소스를 피할 수 있어서 URL이 더 깔끔하고 이해하기 쉽다.
    ```http
    GET /items?userId={userId}&orderId={orderId}
    ```

3. **애플리케이션 상태의 엔진으로서의 하이퍼미디어 (HATEOAS):**<br />
HATEOAS를 구현하여 관련 리소스에 대한 링크를 제공하고, 클라이언트가 URL 구조에서 깊은 중첩 없이 리소스 간을 탐색할 수 있도록 하라. 클라이언트에서 아이템과 연결된 주문 정보가 필요하다면 API 응답에서 `/orders/orderId` 링크를 통해 가져올 수 있다. 응답의 구조를 보면 유일 `item`에 속한 `order`, `user`의 링크이기 때문에 중첩 URL을 사용하지 않고도 이들의 관계를 표현할 수 있다.   
    ```json
    {
      "item": {
        "id": "itemId",
        "name": "Item Name",
        "_links": {
          "self": { "href": "/items/itemId" },
          "order": { "href": "/orders/orderId" },
          "user": { "href": "/users/userId" }
        }
      }
    }
    ```

4. **리소스 집계(Aggregation):**<br />
가능한 경우 관련 데이터를 단일 리소스로 집계하라. 예를 들어, 주문과 그 항목을 별도로 가져오는 대신, 주문과 그 항목을 함께 반환하는 엔드포인트를 설계할 수 있다.
    ```http
    GET /orders/{orderId}
    ```
    ```json
    {
      "orderId": "orderId",
      "userId": "userId",
      "items": [
        { "itemId": "item1", "name": "Item 1" },
        { "itemId": "item2", "name": "Item 2" }
      ]
    }
    ```

5. **리소스 확장:**<br />
클라이언트가 관련 리소스를 확장하여 요청할 수 있도록 하라. 이는 포함할 관련 리소스를 지정하는 쿼리 매개변수를 통해 수행할 수 있다.
    ```http
    GET /orders/{orderId}?expand=items,user
    ```
    ```json
    {
      "orderId": "orderId",
      "userId": "userId",
      "user": { "userId": "userId", "name": "User Name" },
      "items": [
        { "itemId": "item1", "name": "Item 1" },
        { "itemId": "item2", "name": "Item 2" }
      ]
    }
    ```

이러한 전략을 적용하면 API 엔드포인트를 더 유지 관리하기 쉽고 사용자 친화적으로 유지하면서 깊이 중첩된 구조의 복잡성을 피할 수 있다.

## 일관성 없는 이름 짓기
대형 프로젝트에서는 다른 팀 구성원들이 리소스, 엔드포인트, 변수 및 함수를 다르게 명명할 수 있다. 예를 들어, 어떤 사람들은 camelCase(`getUserData`)를 사용하고, 어떤 사람들은 snake_case(`get_user_data`)를 사용하며, 같은 개념에 대해 서로 다른 용어(`userId`, `user_id`, `UserID`)를 쓰기도 한다. 이러한 일관성 없는 이름때문에 혼란과 오류가 생기고 유지보수 시간은 늘어난다.

1. **명명 규칙 확립:**
    모든 팀 구성원이 따를 수 있는 포괄적인 명명 규칙을 문서로 작성하라. 이 문서는 변수, 함수, 엔드포인트, 데이터베이스 테이블 및 기타 모든 요소의 이름을 다루어야 한다.
    > ### 명명 규칙
    > - 변수와 함수: camelCase
    > - 데이터베이스 테이블: snake_case
    > - API 엔드포인트: kebab-case
    > - 상수: UPPER_CASE

2. **린터(Linter)와 코드 포매터 사용:**<br />
린터(예: JavaScript용 ESLint, OpenAPI용 Spectral)와 코드 포매터(예: Prettier)를 개발 워크플로에 통합하라. 이를 구성하여 명명 규칙을 자동으로 적용하게 하라.

3. **코드 리뷰:**<br />
정기적인 코드 리뷰를 실시하여 명명 규칙이 잘 적용되어 있는지 확인하라. 리뷰어들이 합의된 규칙을 엄격하게 따르는지 확인하라.
    ```Markdown
    ## 코드 리뷰 체크리스트
    - [ ] 명명 규칙이 일관되게 적용되었는가?
    - [ ] 변수와 함수 이름이 의미 있고 설명적인가?
    ```

4. **자동화된 CI/CD 검사:**<br />
CI/CD 파이프라인에 명명 규칙 검사를 포함하라. 이를 통해 규칙을 따르지 않는 코드가 메인 코드베이스에 병합되는 것을 방지할 수 있다.

5. **문서화 및 교육:**<br />
명명 규칙의 중요성을 팀에 정기적으로 알리고 새로운 팀원들을 위한 교육 세션을 제공하라. 문서는 쉽게 접근할 수 있고 최신 상태를 유지해야 한다.

이상의 내용을 구현함으로써 일관성 없는 작명의 실수를 줄이고, 깔끔하고 이해하기 쉬우며 유지보수하기 쉬운 코드베이스를 유지할 수 있다.

## 표준 무시

RESTful 원칙이나 일반적인 HTTP 상태 코드를 따르지 않고 API를 개발하는 팀을 상상해보라. 그들은 `201 Created` 대신 `299`와 같은 사용자 정의 상태 코드를 성공을 표현하는데 사용할 수 있으며, 적절한 HTTP 동사를 사용하지 않을 수도 있다(예: 리소스를 생성하기 위해 `GET`을 사용). 이는 혼란을 유발하고, 상호 운용성을 떨어뜨린다. 결국, 애플리케이션 유지보수 및 확장에 어려움을 초래할 수 있다.

1. **RESTful API 원칙 준수:**<br />
올바른 HTTP 메서드(GET, POST, PUT, DELETE)와 적절한 상태 코드(200 OK, 201 Created, 400 Bad Request, 404 Not Found)를 사용하여 REST 원칙을 따르라.
    ```http
    POST /users
    201 Created
    Location: /users/{userId}
    ```

2. **표준 HTTP 상태 코드 사용:**<br />
항상 표준 HTTP 상태 코드를 사용하여 HTTP 요청의 결과를 나타내라. 이는 클라이언트가 응답을 올바르게 이해하고 처리할 수 있도록 보장한다.
    ```http
    200 OK – 요청 성공
    201 Created – 리소스가 성공적으로 생성됨
    400 Bad Request – 요청에 클라이언트 오류가 있음
    401 Unauthorized – 인증 필요
    404 Not Found – 리소스를 찾을 수 없음
    500 Internal Server Error – 서버에 오류 발생
    ```

3. **표준화된 문서 사용:**<br />
OpenAPI(이전의 Swagger)와 같은 표준 형식을 사용하여 API를 문서화하라. API 문서화를 잘하면 다른 개발자들이 쉽게 이해할 수 있다.
    ```yaml
    # openapi.yaml
    openapi: 3.0.0
    info:
      title: Sample API
      version: 1.0.0
    paths:
      /users:
        get:
          summary: 사용자 목록 조회
          responses:
            '200':
              description: 사용자 목록
              content:
                application/json:
                  schema:
                    type: array
                    items:
                      $ref: '#/components/schemas/User'
    ```
    이상의 해결책을 따름으로써 프로젝트가 업계 표준을 준수하여 더 신뢰할 수 있고, 유지보수하기 쉬우며, 그로 인해 다른 시스템과 쉽게 통합할 수 있도록 한다.

# API 문서화의 중요성

중앙화된 API 문서는 일관된 명명 규칙을 유지하고 실수를 피하는 데 크게 도움이 될 수 있다. API 문서가 중요한 이유는 다음과 같다.

1. **단일 참조문서:**<br />
잘 관리된 API 문서는 모든 엔드포인트, 매개변수, 데이터 모델에 대한 단일 출처 역할을 한다. 이를 통해 모든 팀 구성원이 동일한 명명 규칙을 따르도록 돕는다.

2. **일관성:**<br />
API를 문서화함으로써 모든 사람이 구현된 내용을 이해하고 따르게 된다. 이는 API의 다양한 부분에서 일관성 없는 작명의 위험을 줄여준다.

3. **온보딩 용이성:**<br />
새로운 팀원이 이 문서를 참고하여 빠르게 적응할 수 있다. 문서를 통해 올바른 명명 규칙과 구조를 한눈에 확인할 수 있다.

4. **협업 향상:**<br />
명확한 문서를 통해 개발자, 테스터 및 이해관계자들이 API의 작동 방식을 쉽게 이해할 수 있어, 협업이 더 원활해지고 오해가 줄어든다.

5. **자동화된 문서 도구:**<br />
Swagger/OpenAPI, Postman 등의 도구는 코드베이스에서 자동으로 문서를 생성할 수 있다. 이를 통해 문서가 항상 최신 변경 사항과 일치하도록 유지할 수 있다.

# 마무리와 다음 단계
- 명명 규칙은 사소해 보일 수 있지만, 좋은 API의 핵심이다.
- 지금까지 살펴본 가이드라인을 구현하고 변화를 느껴보라.
- API 문서를 먼저 작성하고 팀과 커뮤니케이션하자. 개발 후 수정하는 많은 시간을 줄일 수 있다.
- 코드베이스를 기반으로 문서를 자동으로 만들어 주는 프로세스를 만들자.

<Callout type="warning">
질문 또는 좋은 팁을 알고 있다면 아래 채널을 통해 연락 바랍니다. 피드백을 통해 이 글을 더욱 보완할 수 있기를 바랍니다.
</Callout>